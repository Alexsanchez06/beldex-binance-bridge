{"ast":null,"code":"import axios from 'axios';\nimport { EventEmitter } from 'events';\nimport { encrypt } from '@utils/crypto';\nimport { Warning } from '@utils/error';\nimport config from '@config';\nimport * as Actions from './actions';\nimport * as Events from './events';\nimport dispatcher from './dispatcher';\nconst apiUrl = config.apiUrl,\n      useAPIEncryption = config.useAPIEncryption;\nconst httpClient = axios.create({\n  baseURL: apiUrl\n});\nconst endpoints = {\n  getInfo: '/api/v1/getInfo',\n  getUncomfirmedBeldexTransactions: '/api/v1/getUncomfirmedBeldexTransactions',\n  getSwaps: '/api/v1/getSwaps',\n  swap: '/api/v1/swap',\n  finalizeSwap: '/api/v1/finalizeSwap',\n  createBNBAccount: '/api/v1/createBNBAccount',\n  downloadBNBKeystore: '/api/v1/downloadBNBKeystore',\n  getBalance: '/api/v1/getBalance'\n};\n\nclass Store extends EventEmitter {\n  constructor() {\n    super();\n    this.store = {};\n    dispatcher.register(async payload => {\n      switch (payload.type) {\n        case Actions.GET_INFO:\n          this.getInfo();\n          break;\n\n        case Actions.GET_UNCONFIRMED_BELDEX_TXS:\n          this.getUnconfirmedBeldexTransactions(payload);\n          break;\n\n        case Actions.GET_SWAPS:\n          this.getSwaps(payload);\n          break;\n\n        case Actions.SWAP_TOKEN:\n          this.swapToken(payload);\n          break;\n\n        case Actions.FINALIZE_SWAP_TOKEN:\n          this.finalizeSwap(payload);\n          break;\n\n        case Actions.GET_SWAPS:\n          this.getBalance();\n          break;\n\n        default:\n          break;\n      }\n    });\n  }\n\n  getStore(key) {\n    return this.store[key];\n  }\n\n  async getInfo() {\n    try {\n      const data = await this.fetch(endpoints.getInfo, 'GET');\n      this.store.info = data.result;\n      this.emit(Events.FETCHED_INFO, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getUnconfirmedBeldexTransactions(payload) {\n    try {\n      const data = await this.fetch(endpoints.getUncomfirmedBeldexTransactions, 'GET', payload.content);\n      this.emit(Events.FETCHED_UNCONFIRMED_BELDEX_TXS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getSwaps(payload) {\n    try {\n      const data = await this.fetch(endpoints.getSwaps, 'GET', payload.content);\n      this.emit(Events.FETCHED_SWAPS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async swapToken(payload) {\n    try {\n      const data = await this.fetch(endpoints.swap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAPPED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async finalizeSwap(payload) {\n    try {\n      const data = await this.fetch(endpoints.finalizeSwap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAP_FINALIZED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async fetch(url, method, params = null) {\n    // Encrypt the params if necessary\n    let encrypted = params;\n\n    if (useAPIEncryption && method.toLowerCase() === 'post') {\n      encrypted = encrypt(params, url);\n    }\n\n    const field = method.toLowerCase() === 'post' ? 'data' : 'params';\n\n    try {\n      const _ref = await httpClient({\n        method,\n        url,\n        [field]: encrypted\n      }),\n            data = _ref.data;\n\n      if (data.status === 200 && !data.success) {\n        throw new Warning(data.result);\n      }\n\n      return data;\n    } catch (e) {\n      console.log(\"Failed fetch \".concat(url, \": \"), e); // If we got an error from the api then throw it\n\n      if (e.response && e.response.data) {\n        throw new Error(e.response.data.result);\n      } // Some other error occurred\n\n\n      throw e;\n    }\n  }\n\n  async getBalance() {\n    try {\n      const data = await this.fetch(endpoints.getBalance, 'GET');\n      console.log(data); //this.emit(Events.FETCHED_BALANCE, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n}\n\nexport default new Store();","map":{"version":3,"sources":["/home/nowfil/nowfil/company/beldex/loki-binance-bridge/loki-bridge/src/store/store.js"],"names":["axios","EventEmitter","encrypt","Warning","config","Actions","Events","dispatcher","apiUrl","useAPIEncryption","httpClient","create","baseURL","endpoints","getInfo","getUncomfirmedBeldexTransactions","getSwaps","swap","finalizeSwap","createBNBAccount","downloadBNBKeystore","getBalance","Store","constructor","store","register","payload","type","GET_INFO","GET_UNCONFIRMED_BELDEX_TXS","getUnconfirmedBeldexTransactions","GET_SWAPS","SWAP_TOKEN","swapToken","FINALIZE_SWAP_TOKEN","getStore","key","data","fetch","info","result","emit","FETCHED_INFO","e","ERROR","content","FETCHED_UNCONFIRMED_BELDEX_TXS","FETCHED_SWAPS","TOKEN_SWAPPED","TOKEN_SWAP_FINALIZED","url","method","params","encrypted","toLowerCase","field","status","success","console","log","response","Error"],"mappings":"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","sourcesContent":["import axios from 'axios';\nimport { EventEmitter } from 'events';\nimport { encrypt } from '@utils/crypto';\nimport { Warning } from '@utils/error';\nimport config from '@config';\nimport * as Actions from './actions';\nimport * as Events from './events';\nimport dispatcher from './dispatcher';\n\nconst { apiUrl, useAPIEncryption } = config;\n\nconst httpClient = axios.create({ baseURL: apiUrl });\nconst endpoints = {\n  getInfo: '/api/v1/getInfo',\n  getUncomfirmedBeldexTransactions: '/api/v1/getUncomfirmedBeldexTransactions',\n  getSwaps: '/api/v1/getSwaps',\n  swap: '/api/v1/swap',\n  finalizeSwap: '/api/v1/finalizeSwap',\n  createBNBAccount: '/api/v1/createBNBAccount',\n  downloadBNBKeystore: '/api/v1/downloadBNBKeystore',\n  getBalance: '/api/v1/getBalance',\n};\n\nclass Store extends EventEmitter {\n  constructor() {\n    super();\n    this.store = {};\n\n    dispatcher.register(async payload => {\n      switch (payload.type) {\n        case Actions.GET_INFO:\n          this.getInfo();\n          break;\n        case Actions.GET_UNCONFIRMED_BELDEX_TXS:\n          this.getUnconfirmedBeldexTransactions(payload);\n          break;\n        case Actions.GET_SWAPS:\n          this.getSwaps(payload);\n          break;\n        case Actions.SWAP_TOKEN:\n          this.swapToken(payload);\n          break;\n        case Actions.FINALIZE_SWAP_TOKEN:\n          this.finalizeSwap(payload);\n          break;\n        case Actions.GET_SWAPS:\n          this.getBalance();\n          break;\n        default: break;\n      }\n    });\n  }\n\n  getStore(key) {\n    return this.store[key];\n  };\n\n  async getInfo() {\n    try {\n      const data = await this.fetch(endpoints.getInfo, 'GET');\n      this.store.info = data.result;\n      this.emit(Events.FETCHED_INFO, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getUnconfirmedBeldexTransactions(payload) {\n    try {\n      const data = await this.fetch(endpoints.getUncomfirmedBeldexTransactions, 'GET', payload.content);\n      this.emit(Events.FETCHED_UNCONFIRMED_BELDEX_TXS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getSwaps(payload) {\n    try {\n      const data = await this.fetch(endpoints.getSwaps, 'GET', payload.content);\n      this.emit(Events.FETCHED_SWAPS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async swapToken(payload) {\n    try {\n      const data = await this.fetch(endpoints.swap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAPPED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async finalizeSwap(payload) {\n    try {\n      const data = await this.fetch(endpoints.finalizeSwap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAP_FINALIZED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async fetch(url, method, params = null) {\n    // Encrypt the params if necessary\n    let encrypted = params;\n    if (useAPIEncryption && method.toLowerCase() === 'post') {\n      encrypted = encrypt(params, url);\n    }\n\n    const field = method.toLowerCase() === 'post' ? 'data' : 'params';\n    try {\n      const { data } = await httpClient({\n        method,\n        url,\n        [field]: encrypted\n      });\n\n      if (data.status === 200 && !data.success) {\n        throw new Warning(data.result);\n      }\n\n      return data;\n    } catch (e) {\n      console.log(`Failed fetch ${url}: `, e);\n\n      // If we got an error from the api then throw it\n      if (e.response && e.response.data) {\n        throw new Error(e.response.data.result);\n      }\n\n      // Some other error occurred\n      throw e;\n    }\n  }\n\n  async getBalance() {\n    try {\n      const data = await this.fetch(endpoints.getBalance, 'GET');\n      console.log(data);\n      //this.emit(Events.FETCHED_BALANCE, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n}\n\nexport default new Store();\n"]},"metadata":{},"sourceType":"module"}