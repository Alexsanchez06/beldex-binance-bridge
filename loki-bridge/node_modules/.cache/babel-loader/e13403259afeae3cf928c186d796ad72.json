{"ast":null,"code":"import axios from 'axios';\nimport { EventEmitter } from 'events';\nimport { encrypt } from '@utils/crypto';\nimport { Warning } from '@utils/error';\nimport config from '@config';\nimport * as Actions from './actions';\nimport * as Events from './events';\nimport dispatcher from './dispatcher';\nconst apiUrl = config.apiUrl,\n      useAPIEncryption = config.useAPIEncryption;\nconst httpClient = axios.create({\n  baseURL: apiUrl\n});\nconst endpoints = {\n  getInfo: '/api/v1/getInfo',\n  getUncomfirmedBeldexTransactions: '/api/v1/getUncomfirmedBeldexTransactions',\n  getSwaps: '/api/v1/getSwaps',\n  swap: '/api/v1/swap',\n  finalizeSwap: '/api/v1/finalizeSwap',\n  createBNBAccount: '/api/v1/createBNBAccount',\n  downloadBNBKeystore: '/api/v1/downloadBNBKeystore'\n};\n\nclass Store extends EventEmitter {\n  constructor() {\n    super();\n    this.store = {};\n    dispatcher.register(async payload => {\n      switch (payload.type) {\n        case Actions.GET_INFO:\n          this.getInfo();\n          break;\n\n        case Actions.GET_UNCONFIRMED_LOKI_TXS:\n          this.getUnconfirmedLokiTransactions(payload);\n          break;\n\n        case Actions.GET_SWAPS:\n          this.getSwaps(payload);\n          break;\n\n        case Actions.SWAP_TOKEN:\n          this.swapToken(payload);\n          break;\n\n        case Actions.FINALIZE_SWAP_TOKEN:\n          this.finalizeSwap(payload);\n          break;\n\n        default:\n          break;\n      }\n    });\n  }\n\n  getStore(key) {\n    return this.store[key];\n  }\n\n  async getInfo() {\n    try {\n      const data = await this.fetch(endpoints.getInfo, 'GET');\n      this.store.info = data.result;\n      this.emit(Events.FETCHED_INFO, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getUnconfirmedLokiTransactions(payload) {\n    try {\n      const data = await this.fetch(endpoints.getUncomfirmedLokiTransactions, 'GET', payload.content);\n      this.emit(Events.FETCHED_UNCONFIRMED_LOKI_TXS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getSwaps(payload) {\n    try {\n      const data = await this.fetch(endpoints.getSwaps, 'GET', payload.content);\n      this.emit(Events.FETCHED_SWAPS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async swapToken(payload) {\n    try {\n      const data = await this.fetch(endpoints.swap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAPPED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async finalizeSwap(payload) {\n    try {\n      const data = await this.fetch(endpoints.finalizeSwap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAP_FINALIZED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async fetch(url, method, params = null) {\n    // Encrypt the params if necessary\n    let encrypted = params;\n\n    if (useAPIEncryption && method.toLowerCase() === 'post') {\n      encrypted = encrypt(params, url);\n    }\n\n    const field = method.toLowerCase() === 'post' ? 'data' : 'params';\n\n    try {\n      const _ref = await httpClient({\n        method,\n        url,\n        [field]: encrypted\n      }),\n            data = _ref.data;\n\n      if (data.status === 200 && !data.success) {\n        throw new Warning(data.result);\n      }\n\n      return data;\n    } catch (e) {\n      console.log(\"Failed fetch \".concat(url, \": \"), e); // If we got an error from the api then throw it\n\n      if (e.response && e.response.data) {\n        throw new Error(e.response.data.result);\n      } // Some other error occurred\n\n\n      throw e;\n    }\n  }\n\n}\n\nexport default new Store();","map":{"version":3,"sources":["/home/nowfil/nowfil/company/beldex/loki-binance-bridge/loki-bridge/src/store/store.js"],"names":["axios","EventEmitter","encrypt","Warning","config","Actions","Events","dispatcher","apiUrl","useAPIEncryption","httpClient","create","baseURL","endpoints","getInfo","getUncomfirmedBeldexTransactions","getSwaps","swap","finalizeSwap","createBNBAccount","downloadBNBKeystore","Store","constructor","store","register","payload","type","GET_INFO","GET_UNCONFIRMED_LOKI_TXS","getUnconfirmedLokiTransactions","GET_SWAPS","SWAP_TOKEN","swapToken","FINALIZE_SWAP_TOKEN","getStore","key","data","fetch","info","result","emit","FETCHED_INFO","e","ERROR","getUncomfirmedLokiTransactions","content","FETCHED_UNCONFIRMED_LOKI_TXS","FETCHED_SWAPS","TOKEN_SWAPPED","TOKEN_SWAP_FINALIZED","url","method","params","encrypted","toLowerCase","field","status","success","console","log","response","Error"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,YAAT,QAA6B,QAA7B;AACA,SAASC,OAAT,QAAwB,eAAxB;AACA,SAASC,OAAT,QAAwB,cAAxB;AACA,OAAOC,MAAP,MAAmB,SAAnB;AACA,OAAO,KAAKC,OAAZ,MAAyB,WAAzB;AACA,OAAO,KAAKC,MAAZ,MAAwB,UAAxB;AACA,OAAOC,UAAP,MAAuB,cAAvB;MAEQC,M,GAA6BJ,M,CAA7BI,M;MAAQC,gB,GAAqBL,M,CAArBK,gB;AAEhB,MAAMC,UAAU,GAAGV,KAAK,CAACW,MAAN,CAAa;AAAEC,EAAAA,OAAO,EAAEJ;AAAX,CAAb,CAAnB;AACA,MAAMK,SAAS,GAAG;AAChBC,EAAAA,OAAO,EAAE,iBADO;AAEhBC,EAAAA,gCAAgC,EAAE,0CAFlB;AAGhBC,EAAAA,QAAQ,EAAE,kBAHM;AAIhBC,EAAAA,IAAI,EAAE,cAJU;AAKhBC,EAAAA,YAAY,EAAE,sBALE;AAMhBC,EAAAA,gBAAgB,EAAE,0BANF;AAOhBC,EAAAA,mBAAmB,EAAE;AAPL,CAAlB;;AAUA,MAAMC,KAAN,SAAoBpB,YAApB,CAAiC;AAC/BqB,EAAAA,WAAW,GAAG;AACZ;AACA,SAAKC,KAAL,GAAa,EAAb;AAEAhB,IAAAA,UAAU,CAACiB,QAAX,CAAoB,MAAMC,OAAN,IAAiB;AACnC,cAAOA,OAAO,CAACC,IAAf;AACE,aAAKrB,OAAO,CAACsB,QAAb;AACE,eAAKb,OAAL;AACA;;AACF,aAAKT,OAAO,CAACuB,wBAAb;AACE,eAAKC,8BAAL,CAAoCJ,OAApC;AACA;;AACF,aAAKpB,OAAO,CAACyB,SAAb;AACE,eAAKd,QAAL,CAAcS,OAAd;AACA;;AACF,aAAKpB,OAAO,CAAC0B,UAAb;AACE,eAAKC,SAAL,CAAeP,OAAf;AACA;;AACF,aAAKpB,OAAO,CAAC4B,mBAAb;AACE,eAAKf,YAAL,CAAkBO,OAAlB;AACA;;AACF;AAAS;AAhBX;AAkBD,KAnBD;AAoBD;;AAEDS,EAAAA,QAAQ,CAACC,GAAD,EAAM;AACZ,WAAO,KAAKZ,KAAL,CAAWY,GAAX,CAAP;AACD;;AAED,QAAMrB,OAAN,GAAgB;AACd,QAAI;AACF,YAAMsB,IAAI,GAAG,MAAM,KAAKC,KAAL,CAAWxB,SAAS,CAACC,OAArB,EAA8B,KAA9B,CAAnB;AACA,WAAKS,KAAL,CAAWe,IAAX,GAAkBF,IAAI,CAACG,MAAvB;AACA,WAAKC,IAAL,CAAUlC,MAAM,CAACmC,YAAjB,EAA+BL,IAAI,CAACG,MAApC;AACD,KAJD,CAIE,OAAOG,CAAP,EAAU;AACV,WAAKF,IAAL,CAAUlC,MAAM,CAACqC,KAAjB,EAAwBD,CAAxB;AACD;AACF;;AAED,QAAMb,8BAAN,CAAqCJ,OAArC,EAA8C;AAC5C,QAAI;AACF,YAAMW,IAAI,GAAG,MAAM,KAAKC,KAAL,CAAWxB,SAAS,CAAC+B,8BAArB,EAAqD,KAArD,EAA4DnB,OAAO,CAACoB,OAApE,CAAnB;AACA,WAAKL,IAAL,CAAUlC,MAAM,CAACwC,4BAAjB,EAA+CV,IAAI,CAACG,MAApD;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU;AACV,WAAKF,IAAL,CAAUlC,MAAM,CAACqC,KAAjB,EAAwBD,CAAxB;AACD;AACF;;AAED,QAAM1B,QAAN,CAAeS,OAAf,EAAwB;AACtB,QAAI;AACF,YAAMW,IAAI,GAAG,MAAM,KAAKC,KAAL,CAAWxB,SAAS,CAACG,QAArB,EAA+B,KAA/B,EAAsCS,OAAO,CAACoB,OAA9C,CAAnB;AACA,WAAKL,IAAL,CAAUlC,MAAM,CAACyC,aAAjB,EAAgCX,IAAI,CAACG,MAArC;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU;AACV,WAAKF,IAAL,CAAUlC,MAAM,CAACqC,KAAjB,EAAwBD,CAAxB;AACD;AACF;;AAED,QAAMV,SAAN,CAAgBP,OAAhB,EAAyB;AACvB,QAAI;AACF,YAAMW,IAAI,GAAG,MAAM,KAAKC,KAAL,CAAWxB,SAAS,CAACI,IAArB,EAA2B,MAA3B,EAAmCQ,OAAO,CAACoB,OAA3C,CAAnB;AACA,WAAKL,IAAL,CAAUlC,MAAM,CAAC0C,aAAjB,EAAgCZ,IAAI,CAACG,MAArC;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU;AACV,WAAKF,IAAL,CAAUlC,MAAM,CAACqC,KAAjB,EAAwBD,CAAxB;AACD;AACF;;AAED,QAAMxB,YAAN,CAAmBO,OAAnB,EAA4B;AAC1B,QAAI;AACF,YAAMW,IAAI,GAAG,MAAM,KAAKC,KAAL,CAAWxB,SAAS,CAACK,YAArB,EAAmC,MAAnC,EAA2CO,OAAO,CAACoB,OAAnD,CAAnB;AACA,WAAKL,IAAL,CAAUlC,MAAM,CAAC2C,oBAAjB,EAAuCb,IAAI,CAACG,MAA5C;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU;AACV,WAAKF,IAAL,CAAUlC,MAAM,CAACqC,KAAjB,EAAwBD,CAAxB;AACD;AACF;;AAED,QAAML,KAAN,CAAYa,GAAZ,EAAiBC,MAAjB,EAAyBC,MAAM,GAAG,IAAlC,EAAwC;AACtC;AACA,QAAIC,SAAS,GAAGD,MAAhB;;AACA,QAAI3C,gBAAgB,IAAI0C,MAAM,CAACG,WAAP,OAAyB,MAAjD,EAAyD;AACvDD,MAAAA,SAAS,GAAGnD,OAAO,CAACkD,MAAD,EAASF,GAAT,CAAnB;AACD;;AAED,UAAMK,KAAK,GAAGJ,MAAM,CAACG,WAAP,OAAyB,MAAzB,GAAkC,MAAlC,GAA2C,QAAzD;;AACA,QAAI;AAAA,mBACe,MAAM5C,UAAU,CAAC;AAChCyC,QAAAA,MADgC;AAEhCD,QAAAA,GAFgC;AAGhC,SAACK,KAAD,GAASF;AAHuB,OAAD,CAD/B;AAAA,YACMjB,IADN,QACMA,IADN;;AAOF,UAAIA,IAAI,CAACoB,MAAL,KAAgB,GAAhB,IAAuB,CAACpB,IAAI,CAACqB,OAAjC,EAA0C;AACxC,cAAM,IAAItD,OAAJ,CAAYiC,IAAI,CAACG,MAAjB,CAAN;AACD;;AAED,aAAOH,IAAP;AACD,KAZD,CAYE,OAAOM,CAAP,EAAU;AACVgB,MAAAA,OAAO,CAACC,GAAR,wBAA4BT,GAA5B,SAAqCR,CAArC,EADU,CAGV;;AACA,UAAIA,CAAC,CAACkB,QAAF,IAAclB,CAAC,CAACkB,QAAF,CAAWxB,IAA7B,EAAmC;AACjC,cAAM,IAAIyB,KAAJ,CAAUnB,CAAC,CAACkB,QAAF,CAAWxB,IAAX,CAAgBG,MAA1B,CAAN;AACD,OANS,CAQV;;;AACA,YAAMG,CAAN;AACD;AACF;;AA5G8B;;AA+GjC,eAAe,IAAIrB,KAAJ,EAAf","sourcesContent":["import axios from 'axios';\nimport { EventEmitter } from 'events';\nimport { encrypt } from '@utils/crypto';\nimport { Warning } from '@utils/error';\nimport config from '@config';\nimport * as Actions from './actions';\nimport * as Events from './events';\nimport dispatcher from './dispatcher';\n\nconst { apiUrl, useAPIEncryption } = config;\n\nconst httpClient = axios.create({ baseURL: apiUrl });\nconst endpoints = {\n  getInfo: '/api/v1/getInfo',\n  getUncomfirmedBeldexTransactions: '/api/v1/getUncomfirmedBeldexTransactions',\n  getSwaps: '/api/v1/getSwaps',\n  swap: '/api/v1/swap',\n  finalizeSwap: '/api/v1/finalizeSwap',\n  createBNBAccount: '/api/v1/createBNBAccount',\n  downloadBNBKeystore: '/api/v1/downloadBNBKeystore',\n};\n\nclass Store extends EventEmitter {\n  constructor() {\n    super();\n    this.store = {};\n\n    dispatcher.register(async payload => {\n      switch(payload.type) {\n        case Actions.GET_INFO:\n          this.getInfo();\n          break;\n        case Actions.GET_UNCONFIRMED_LOKI_TXS:\n          this.getUnconfirmedLokiTransactions(payload);\n          break;\n        case Actions.GET_SWAPS:\n          this.getSwaps(payload);\n          break;\n        case Actions.SWAP_TOKEN:\n          this.swapToken(payload);\n          break;\n        case Actions.FINALIZE_SWAP_TOKEN:\n          this.finalizeSwap(payload);\n          break;\n        default: break;\n      }\n    });\n  }\n\n  getStore(key) {\n    return this.store[key];\n  };\n\n  async getInfo() {\n    try {\n      const data = await this.fetch(endpoints.getInfo, 'GET');\n      this.store.info = data.result;\n      this.emit(Events.FETCHED_INFO, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getUnconfirmedLokiTransactions(payload) {\n    try {\n      const data = await this.fetch(endpoints.getUncomfirmedLokiTransactions, 'GET', payload.content);\n      this.emit(Events.FETCHED_UNCONFIRMED_LOKI_TXS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async getSwaps(payload) {\n    try {\n      const data = await this.fetch(endpoints.getSwaps, 'GET', payload.content);\n      this.emit(Events.FETCHED_SWAPS, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async swapToken(payload) {\n    try {\n      const data = await this.fetch(endpoints.swap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAPPED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async finalizeSwap(payload) {\n    try {\n      const data = await this.fetch(endpoints.finalizeSwap, 'POST', payload.content);\n      this.emit(Events.TOKEN_SWAP_FINALIZED, data.result);\n    } catch (e) {\n      this.emit(Events.ERROR, e);\n    }\n  }\n\n  async fetch(url, method, params = null) {\n    // Encrypt the params if necessary\n    let encrypted = params;\n    if (useAPIEncryption && method.toLowerCase() === 'post') {\n      encrypted = encrypt(params, url);\n    }\n\n    const field = method.toLowerCase() === 'post' ? 'data' : 'params';\n    try {\n      const { data } = await httpClient({\n        method,\n        url,\n        [field]: encrypted\n      });\n\n      if (data.status === 200 && !data.success) {\n        throw new Warning(data.result);\n      }\n\n      return data;\n    } catch (e) {\n      console.log(`Failed fetch ${url}: `, e);\n\n      // If we got an error from the api then throw it\n      if (e.response && e.response.data) {\n        throw new Error(e.response.data.result);\n      }\n\n      // Some other error occurred\n      throw e;\n    }\n  }\n}\n\nexport default new Store();\n"]},"metadata":{},"sourceType":"module"}